# Function to display the menu and get user input
function Show-Menu {
    Clear-Host
    Write-Host "Welcome to MalwareInsight"
    Write-Host "1. Set-Up MalwareInsight for new sandbox environment"
    Write-Host "2. Start VM"
    Write-Host "3. Connect to SSH"
	Write-Host "4. Shut down VM"
	Write-Host "5. Transfer File"
    Write-Host "Q. Quit"
    Write-Host ""
    $selection = Read-Host "Please select an option"
    return $selection
}


# Function to check if VBoxManage.exe is accessible
function CheckVBoxManage {
    if (Test-Path -Path $VBoxManagePath -PathType Leaf) {
        return $true
    }
    else {
        return $false
    }
}

# Function to handle the "First-time user?" option
function FirstTimeUser {
    Clear-Host
    Write-Host "Welcome, first-time user!"
    Write-Host ""

    $defaultPath = "C:\Program Files\Oracle\VirtualBox\VBoxManage.exe"
    $useDefault = Read-Host "Do you want to use the default path for VBoxManage? (Y/N)"
    $vboxManagePath = ""

    if ($useDefault -eq "Y" -or $useDefault -eq "y") {
        $vboxManagePath = $defaultPath
    }
    else {
        $vboxManagePath = Read-Host "Please enter the path to VBoxManage executable"
    }

    if (CheckVBoxManage) {
        Set-Variable -Name "VBoxManagePath" -Value $vboxManagePath -Scope Global
        Write-Host "VBoxManage executable found at '$VBoxManagePath'."
    }
    else {
        Write-Host "VBoxManage executable not found at '$VBoxManagePath'. Please make sure the path is correct."
		Read-Host "Press Enter to continue"
		$selection
	}
    Read-Host "Press Enter to continue"
	SetupVM
	
}


# Function to handle the "Start VM" option
function SetupVM {
    Clear-Host
    Write-Host "Starting VM..."

    if (CheckVBoxManage) {
        $vmName = Read-Host "Please enter the name of the VM"
		Set-Variable -Name "vmName" -Value $vmName -Scope Global
		$sourceSnapshotName = Read-Host "Please enter the name of the source snapshot"
		Set-Variable -Name "sourceSnapshotName" -Value $sourceSnapshotName -Scope Global
		$newSnapshotName = "MalwareInsight Snapshot"
		Set-Variable -Name "newSnapshotName" -Value $newSnapshotName -Scope Global


		# Check if the virtual machine is running
		$vmRunning = (Start-Process -FilePath $VBoxManagePath -ArgumentList "showvminfo `"$vmName`" --machinereadable" -Wait -NoNewWindow -PassThru).ExitCode -eq 0

		if ($vmRunning) {
			Write-Host "Virtual machine is already running."
		}
		else {
			# Start the virtual machine with the original snapshot
			Start-Process -FilePath $VBoxManagePath -ArgumentList "startvm `"$vmName`" --type gui --snapshot `"$sourceSnapshotName`"" -Wait
		}

		# Wait for the virtual machine to be running
		Start-Sleep -Seconds 10

		# Take a new snapshot if the virtual machine is running
		$vmRunning = (Start-Process -FilePath $VBoxManagePath -ArgumentList "showvminfo `"$vmName`" --machinereadable" -Wait -NoNewWindow -PassThru).ExitCode -eq 0

		if ($vmRunning) {
			# Take a new snapshot from the original state
			Start-Process -FilePath $VBoxManagePath -ArgumentList "snapshot `"$vmName`" take `"$newSnapshotName`"" -Wait
			Write-Host "New snapshot '$newSnapshotName' created from the original snapshot."

			# Power off the virtual machine
			Start-Process -FilePath $VBoxManagePath -ArgumentList "controlvm `"$vmName`" poweroff" -Wait
			# Wait for the virtual machine to be powered off
			Start-Sleep -Seconds 10
		}
		else {
			Write-Host "Virtual machine is not running. Skipping snapshot creation and shut down."
		}

		# Restore the new snapshot and launch the virtual machine
		Start-Process -FilePath $VBoxManagePath -ArgumentList "snapshot `"$vmName`" restore `"$newSnapshotName`" --live" -Wait
		Write-Host "New snapshot '$newSnapshotName' restored. Checking validity..."
		Start-Process -FilePath $VBoxManagePath -ArgumentList "startvm `"$vmName`" --type gui" -Wait
		Clear-Host
		Write-Host "Malware Sandbox set-up complete. Please review the following:"
		Write-Host "Virtual Machine Name: $vmName"
		Write-Host "Base-line Snapshot: $sourceSnapshotName"
		Write-Host "-- MalwareInsight will use this snapshot as the base point once analysis is complete and ready for re-use"
		Write-Host "Snapshot for Malware Analysis: $newSnapshotName"
		Write-Host
		Write-Host "If these settings are incorrect, feel free to go through the Set-Up once more."
		Read-Host "Press Enter to continue"
		Clear-Host
		Write-Host "Turning off restored snapshot. Start Sandbox when ready to begin analysis."
		Start-Process -FilePath $VBoxManagePath -ArgumentList "controlvm `"$vmName`" poweroff" -Wait
		Write-Host "Sandbox Setup Complete!"
		Read-Host "Press Enter to continue"



    }
	else {
        Write-Host "VBoxManage executable not found. Please ensure it is accessible."
    }
}

# Function to handle security implementations for the virtual machine
function SecureVM{
	$vmName = Read-Host "Please enter the name of the VM"

	# Disable copy and paste
	Start-Process -FilePath $VBoxManagePath -ArgumentList "modifyvm","$vmName","--clipboard","disabled"
    Start-Sleep -Seconds 5
	# Disable drag and drop
	Start-Process -FilePath $VBoxManagePath -ArgumentList "modifyvm","$vmName","--draganddrop","disabled"
	Start-Sleep -Seconds 5
	Write-Host "VM copy-paste, drag and drop, and shared folder settings modified for Malware Analysis."
	Write-Host "Setting network options: Applying deny all, bridged connection, allowing SCP only between host and machine."
	# Get the current VM configuration
	$output = Start-Process -FilePath $VBoxManagePath -ArgumentList "showvminfo","$vmName","--machinereadable"

	# Extract the names of the active network adapters
	$activeAdapters = $output | Select-String -Pattern '^(nic\d+)="[^"]+"$' | ForEach-Object { $_.Matches.Groups[1].Value }

	# Delete the active network adapters
	foreach ($adapter in $activeAdapters) {
		Start-Process -FilePath $VBoxManagePath -ArgumentList "modifyvm","$vmName","--$adapter","none"
		
	}
	Start-Process -FilePath $VBoxManagePath -ArgumentList "modifyvm","$vmName","--nic1","bridged"
	Start-Process -FilePath $VBoxManagePath -ArgumentList "modifyvm","$vmName","--nicpromisc1","deny"
	Start-Process -FilePath $VBoxManagePath -ArgumentList "modifyvm","$vmName","--natpf1","delete","allin"


	Write-Host "Security measures have been applied to the Malware Sandbox."

	Read-Host "Press Enter to continue"


}

function StartVM{
		Clear-Host
		Write-Host "Starting $vmName. Ensure you have gone through the MalwareInsight setup before continuing any further."
		Write-Host "MalwareInsight is not liable for any damage caused to your system. Always ensure your host machine has a working anti-virus and latest patches!"
		$answer = Read-Host "Agree to proceed? Y/N"
		if ($answer -eq "Y" -or $answer -eq "y") {
			SecureVM
			Write-Host "Starting sandbox..."
			Start-Process -FilePath $VBoxManagePath -ArgumentList "startvm `"$vmName`" --type gui" -Wait
			Clear-Host
			Write-Host "|----------------------------------------------------------------------------------------|"
			Write-Host "|								    IMPORTANT:											 |"
			Write-Host "| VirtualBox started. Setting device firewall rules.									 |"
			Write-Host "| ONLY press enter once you are in the desktop, this will allow for successful config    |"
			Write-Host "| 																						 |"
			Write-Host "| 						Ready to set Network Rules?                                      |"
			Write-Host "|----------------------------------------------------------------------------------------|"
			Read-Host "Press Enter to continue..."
			NetworkSetup

		}
		else {
			Write-Host "Returning to main menu."
			$selection
		}


}





# Function to handle the "Connect to SSH" option
function ConnectToSSH {
    Clear-Host
    Write-Host "Connect to SSH option"

    $vmName = Read-Host "Please enter the name of the VM"

    $sshUsername = Read-Host "Please enter the SSH username"
    $sshIP = Read-Host "Please enter the SSH IP address"
    $sshPassword = Read-Host "Please enter the SSH password" -AsSecureString

    # Convert the secure string password to plain text
    $sshPasswordPlain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($sshPassword))

    # Check if 'ssh' command is available
    $sshPath = Get-Command -Name ssh -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source

    if ([string]::IsNullOrWhiteSpace($sshPath)) {
        Write-Host "'ssh' command not found."

        $installSSH = Read-Host "Do you want to install OpenSSH? (Y/N)"
        if ($installSSH -eq "Y" -or $installSSH -eq "y") {
            # Add installation logic here
            Write-Host "OpenSSH installation steps..."
        }
        else {
            Write-Host "SSH connection cannot be established without OpenSSH."
            Read-Host "Press Enter to continue"
            return
        }
    }

    # Attempt SSH connection
    Write-Host "Attempting to connect to SSH..."
    Start-Process -FilePath $sshPath -ArgumentList "-l", $sshUsername, "-oStrictHostKeyChecking=no", "-oUserKnownHostsFile=/dev/null", "-oPasswordAuthentication=yes", "-oPubkeyAuthentication=no", "-oNumberOfPasswordPrompts=1", "-oConnectTimeout=30", $sshIP

    Write-Host "SSH connection has been established."

    Read-Host "Press Enter to continue"
}

# Function to handle the "Shutdown Virtual Machine" option
function ShutdownVM {
    Clear-Host

	# Check if VBoxManagePath is null or empty and prompt user for input
	if ([string]::IsNullOrWhiteSpace($VBoxManagePath)) {
		$defaultPath = "C:\Program Files\Oracle\VirtualBox\VBoxManage.exe"
		$useDefault = Read-Host "Do you want to use the default path for VBoxManage? (Y/N)"
		$vboxManagePath = ""

		if ($useDefault -eq "Y" -or $useDefault -eq "y") {
			$vboxManagePath = $defaultPath
		}
		else {
			$vboxManagePath = Read-Host "Please enter the path to VBoxManage executable"
		}
	}

	while ([string]::IsNullOrWhiteSpace($vmName) -or [string]::IsNullOrWhiteSpace($sourceSnapshotName) -or [string]::IsNullOrWhiteSpace($newSnapshotName)) {
		Write-Host "One or more values are missing. Please enter the values manually."
		
		if ([string]::IsNullOrWhiteSpace($vmName)) {
			$vmName = Read-Host "Please enter the name of the VM"
		}
		
		if ([string]::IsNullOrWhiteSpace($sourceSnapshotName)) {
			$sourceSnapshotName = Read-Host "Please enter the name of the source snapshot"
		}
		
		if ([string]::IsNullOrWhiteSpace($newSnapshotName)) {
			$newSnapshotName = Read-Host "Please enter the name of the new snapshot"
		}
	}

	# Power off the virtual machine
	Start-Process -FilePath $VBoxManagePath -ArgumentList "controlvm `"$vmName`" poweroff" -Wait
	Write-Host "Virtual machine '$vmName' is shut down."
	Start-Sleep -Seconds 10

	
	# Restore the source snapshot
	Start-Process -FilePath $VBoxManagePath -ArgumentList "snapshot `"$vmName`" restore `"$sourceSnapshotName`"" -Wait
	Write-Host "Restored the source snapshot '$sourceSnapshotName' for virtual machine '$vmName'."
	Start-Sleep -Seconds 5

	# Delete the new snapshot
	Start-Process -FilePath $VBoxManagePath -ArgumentList "snapshot `"$vmName`" delete `"$newSnapshotName`"" -Wait
	Write-Host "Deleted the new snapshot '$newSnapshotName' for virtual machine '$vmName'."


	Read-Host "Press Enter to continue"

}


function Test-SSHCommand {
    param (
        [string]$CommandName
    )
    
    $commandPath = Get-Command $CommandName -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source
    
    return [bool]($commandPath -ne $null)
}

function Transfer-File {
    Add-Type -AssemblyName System.Windows.Forms
    
    $openFileDialog = New-Object System.Windows.Forms.OpenFileDialog
    $openFileDialog.Filter = "ZIP Files (*.zip)|*.zip|RAR Files (*.rar)|*.rar|7ZIP Files (*.7z)|*.7z"
    $openFileDialog.Title = "Select a file to transfer"
    
    # Show the file dialog and check if the user selected a file
    if ($openFileDialog.ShowDialog() -eq 'OK') {
        $filePath = (Resolve-Path -Path $openFileDialog.FileName).Path
    } else {
        Write-Host "No file selected."
        return
    }
    
    $username = Read-Host "Enter the SSH username:"
    $ip = Read-Host "Enter the IP of the Virtual Machine:"
    
    # Validate if the SCP command exists
    if (-not (Test-SSHCommand "scp")) {
        Write-Host "Error: SCP command not found. Please ensure that OpenSSH is installed."
        return
    }
    
    # Construct the destination path on the Windows machine (user's desktop)
    $destinationPath = "C:\Users\$username\Desktop"
    
    # Construct the SCP command
    $scpArguments = "`"$filePath`" ${username}@${ip}:`"$destinationPath`""
    $errorLogFile = "scp_error.log"
    $scpProcess = Start-Process -FilePath "scp" -ArgumentList $scpArguments -NoNewWindow -RedirectStandardError $errorLogFile -PassThru
    
    # Wait for the SCP process to complete
    $scpProcess.WaitForExit()
    
    # Check the exit code of the SCP process
    if ($scpProcess.ExitCode -eq 0) {
        Write-Host "File transferred successfully!"
    } else {
        Write-Host "File transfer failed. Check the error log for details: $errorLogFile"
    }
    
    Start-Sleep -Seconds 3
}

function NetworkSetup {
		# Install the Posh-SSH module if not already installed
		# Check if Posh-SSH module is installed
	if (-not (Get-Module -Name Posh-SSH -ListAvailable)) {
		# Install the Posh-SSH module
		Install-Module -Name Posh-SSH -Force -AllowClobber -Scope CurrentUser
	}

	# Check if Posh-SSH module is imported
	if (-not (Get-Module -Name Posh-SSH)) {
		# Import the Posh-SSH module
		Import-Module -Name Posh-SSH
	}

	# SSH connection parameters
	$vmName = Read-Host "Please enter the IP address of the virtual machine"
	$sshUsername = Read-Host "Please enter the SSH username"
	$sshPassword = Read-Host -AsSecureString "Please enter the SSH password"
	$sshPasswordPlain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($sshPassword))

	# Establish SSH connection
	$sshSession = New-SSHSession -ComputerName $vmName -Credential (New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $sshUsername, $sshPassword)


	# Run Windows Firewall rules commands remotely
	$firewallCommands = @(
		"netsh advfirewall set allprofiles firewallpolicy blockinbound,blockoutbound",
		"netsh advfirewall firewall add rule name=`"Allow SSH`" dir=in action=allow protocol=TCP localport=22",
		"netsh advfirewall firewall add rule name=`"Allow SCP`" dir=in action=allow protocol=TCP localport=22"
	)

	foreach ($command in $firewallCommands) {
		Invoke-SSHCommand -SessionId $sshSession.SessionId -Command $command
	}


	# Close SSH session
	Remove-SSHSession -SessionId $sshSession.SessionId

	Write-Host "Windows Firewall rules configured on the virtual machine '$vmName'."

	Read-Host "Press Enter to continue"


}


# Main script
$selection = Show-Menu

while ($selection -ne 'q') {
    switch ($selection) {
        '1' { FirstTimeUser }
        '2' { StartVM }
        '3' { NetworkSetup }
		'4' { ShutDownVM }
		'5' { Transfer-File}
        default {
            Write-Host "Invalid option. Please try again."
            Read-Host "Press Enter to continue"
        }
    }

    $selection = Show-Menu
}

Write-Host "Goodbye!"
pause
