import csv
import os
import sys
import pandas as pd
import networkx as nx
import pydot
from PIL import Image

def process_csv(input_file, process_name):
    pids_to_monitor = set()
    rows_to_export = []

    with open(input_file, 'r', newline='', encoding='utf-8') as csv_file:
        reader = csv.reader(csv_file)
        headers = next(reader)

        process_name_index = headers.index('Process Name')
        pid_index = headers.index('PID')
        parent_pid_index = headers.index('Parent PID')
        path_index = headers.index('Path')

        for row in reader:
            current_process_name = row[process_name_index].strip()
            current_pid = row[pid_index].strip()
            current_parent_pid = row[parent_pid_index].strip()
            current_path = row[path_index].strip()

            if current_process_name == process_name or process_name in current_path:
                pids_to_monitor.add(current_pid)
                rows_to_export.append(row)

            if current_pid in pids_to_monitor or current_parent_pid in pids_to_monitor:
                pids_to_monitor.add(current_pid)
                rows_to_export.append(row)

    print("Recorded PIDs:")
    for pid in pids_to_monitor:
        print(pid)

    # Read the CSV file into a DataFrame
    df = pd.DataFrame(rows_to_export, columns=headers)

    # Create a dictionary to store the process tree
    G = nx.DiGraph()

    # Iterate through rows and build the process tree
    for index, row in df.iterrows():
        pid = row['PID']
        process_name = row['Process Name']
        parent_pid = row['Parent PID']

        if process_name.strip():  # Check if process name is not empty
            G.add_node(pid, label=process_name)  # Add nodes with 'label' attribute

        if not pd.isna(parent_pid):
            G.add_edge(parent_pid, pid)  # Add edges

    # Extract weakly connected components as process_trees
    process_trees = list(nx.weakly_connected_components(G))

    # Define the path to the "Reports" directory 
    reports_folder = "reports"
    script_dir = os.path.dirname(os.path.abspath(file))

    # Specify the save path including the 'reports' folder
    if save_path is None:
        save_path = os.path.join(script_dir, reports_folder)

    # Ensure the 'reports' folder exists
    os.makedirs(save_path, exist_ok=True)

    plt.savefig(os.path.join(save_path, 'process_tree.png'), format='png', bbox_inches='tight', pad_inches=0) 

    # Function to visualize a process tree
    def visualize_process_tree(tree_index):
        subgraph = G.subgraph(process_trees[tree_index])

        labels = nx.get_node_attributes(subgraph, 'label')  # Use 'label' as the attribute
        pos = nx.spring_layout(subgraph, seed=42)

        # Create a Pydot graph from the NetworkX graph
        pydot_graph = nx.drawing.nx_pydot.to_pydot(subgraph)

        # Specify the filename within the "Reports" directory
        image_filename = os.path.join(reports_dir, f'process_tree_{tree_index}.png')

        # Render the Pydot graph to a DOT file
        dot_filename = os.path.join(reports_dir, f'process_tree_{tree_index}.dot')
        pydot_graph.write_dot(dot_filename)

        # Convert the DOT file to an image (PNG format)
        try:
            pydot.graph_from_dot_file(dot_filename)[0].write_png(image_filename)
            print(f"Process Tree {tree_index + 1} visualization saved as {image_filename}")
        except Exception as e:
            print(f"Error generating image for Process Tree {tree_index + 1}: {str(e)}")

        # Display the image
        img = Image.open(image_filename)
        img.show()

    # Print associated PIDs and process names and visualize each process tree
    for i, tree_nodes in enumerate(process_trees):
        print(f"Process Tree {i + 1}:")
        labels = nx.get_node_attributes(G, 'label')  # Retrieve labels here
        for node in tree_nodes:
            process_name = labels.get(node, 'N/A')  # Use .get() to handle missing labels
            print(f"  PID: {node}, Process Name: {process_name}")

        # Visualize the process tree
        visualize_process_tree(i)

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python script_name.py input_file.csv process_name")
        sys.exit(1)

    input_file = sys.argv[1]
    process_name = sys.argv[2]
    print("running_process.csv")
    process_csv(input_file, process_name)
