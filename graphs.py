"""
    Group 40 - Malware Sandbox
        Swinburne University of Technology
        Name: MalwareInsight Graphs Generation
        Author: Lachlan Stanbrook, Daniel Pesavento, Ahmed Elmi
        Date: 21/09/2023

        
        Description:
        Utilises collected data to create an assortment of visualisations in order
        to help users process and understand the data collecting pertaining to the malware.
"""

import matplotlib.pyplot as plt
import sys
import os
import matplotlib.patches as patches
import numpy as np
from matplotlib.patches import Wedge, Arrow, Rectangle
import subprocess
import pandas as pd
import pyshark
import collections
import csv
import json

# REGISTRY OPERATIONS BARCHART
def plot_registry_operations(event_counts):
    # Extract the keys (event types) and their counts
    events = list(event_counts.keys())
    counts = list(event_counts.values())
    
    # Create a bar chart
    plt.figure(figsize=(10,6))
    plt.barh(events, counts, color='skyblue')
    plt.xlabel('Count')
    plt.ylabel('Registry Operation')
    plt.title('Registry Operations Count')
    plt.gca().invert_yaxis()  # This will show the event with the highest count on top
    plt.tight_layout()
    
    # Save the chart as an image
    registry_operations_image_path = r'reports\registry_operations.png'
    plt.savefig(registry_operations_image_path)
    plt.close()

    return registry_operations_image_path

# REGISTRY OPERATIONS PIE CHART

def plot_registry_operations_pie(event_counts):
    # Extract the keys (event types) and their counts
    events = list(event_counts.keys())
    counts = list(event_counts.values())
    total = sum(counts)

    # Calculate percentages
    percentages = [(count/total)*100 for count in counts]
    
    # Create labels for the legend which include the operation and percentage
    labels_with_percentages = [f'{event} ({percentage:.2f}%)' for event, percentage in zip(events, percentages)]
    
    # Create a pie chart
    fig, ax = plt.subplots(figsize=(10,6))
    wedges = ax.pie(counts, startangle=90, colors=plt.cm.Paired.colors, wedgeprops=dict(width=0.4))

    # Draw a circle at the center of pie to make it look like a donut
    centre_circle = plt.Circle((0,0),0.70,fc='white')
    fig.gca().add_artist(centre_circle)

    # Set the title
    ax.set_title('Registry Operations Distribution')
    
    # Position the labels outside of the pie using legend
    ax.legend(wedges[0], labels_with_percentages, title="Registry Operations", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
    
    # Save the chart as an image
    registry_operations_pie = r'reports\registry_pie.png'
    plt.savefig(registry_operations_pie, bbox_inches='tight')  # bbox_inches='tight' to fit the legend in the saved image
    # Optionally display the chart
    plt.close()

    return registry_operations_pie

# PROCESS BARCHART

def plot_processes_created(process_counts):
    # Extract the processes and their counts
    processes = list(process_counts.keys())
    counts = list(process_counts.values())
    
    # Create a bar chart
    plt.figure(figsize=(10,6))
    plt.barh(processes, counts, color='skyblue')
    plt.xlabel('Count')
    plt.ylabel('Process Created')
    plt.title('Processes Created Count')
    plt.gca().invert_yaxis()  # This will show the process with the highest count on top
    plt.tight_layout()
    
    # Save the chart as an image
    processes_created_image_path = r'reports\processes_created.png'
    plt.savefig(processes_created_image_path)
    # Optionally display the chart
    plt.close()

    return processes_created_image_path

# FILES BARCHART

def plot_files_created(event_counts):
    # Extract the keys (event types) and their counts
    events = list(event_counts.keys())
    counts = list(event_counts.values())
    
    # Create a bar chart
    plt.figure(figsize=(10,6))
    plt.barh(events, counts, color='skyblue')
    plt.xlabel('Count')
    plt.ylabel('File Operation')
    plt.title('Files Created Count')
    plt.gca().invert_yaxis()  # This will show the event with the highest count on top
    plt.tight_layout()
    
    # Save the chart as an image
    files_created_image_path = r'reports\files_created.png'
    plt.savefig(files_created_image_path)
    # Optionally display the chart
    plt.close()

    return files_created_image_path

# THREAT RATING GRAPH

# Define section names and corresponding colors
def threat_graph(classification):
    sections = ["Malicious", "Suspicious", "Not Malicious", "Harmless"]
    colors = ["red", "orange", "yellowgreen", "green"]

    # Create a new figure
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-0.5, 1.5)  # Adjust y limits for half-circle
    ax.set_aspect('equal', 'box')  # This will make sure the plot remains a circle
    ax.axis('off')  # Turn off the axis

    # Set up for the circular segments
    start_angle = 0  # Start from the right-most side of the top half-circle
    arc = 180 / len(sections)  # Adjust arc for half-circle
    radius = 1
    width = 0.4

    for i, cls in enumerate(sections):
        if cls == classification:
            alpha = 1.0
            color = colors[i]
        else:
            alpha = 0.5
            color = 'gray'

        theta1 = start_angle + i * arc
        theta2 = start_angle + (i + 1) * arc
        arc_middle = 0.5 * (theta1 + theta2)

        # Draw the segment
        ax.add_patch(Wedge(center=(0, 0), r=radius, theta1=theta1, theta2=theta2, facecolor=color, edgecolor='black', alpha=alpha, width=width, linewidth=2.5))

        # Label the segment
        label_radius = radius - 0.5 * width
        label_x = label_radius * np.cos(np.radians(arc_middle))
        label_y = label_radius * np.sin(np.radians(arc_middle))
        ax.text(label_x, label_y, cls, ha='center', va='center', fontsize=12, color='black' if alpha == 1.0 else 'gray')
        
        # If this is the highlighted segment, draw an arrow pointing to it
        if cls == classification:
            arrow_length = 0.5
            arrow_x = arrow_length * np.cos(np.radians(arc_middle))
            arrow_y = arrow_length * np.sin(np.radians(arc_middle))
            ax.arrow(0, 0, arrow_x, arrow_y, head_width=0.1, head_length=0.1, fc='black', ec='black', lw=10.5,)

##    # Add a stand for the arrow
##    stand_width = 0.4
##    stand_height = 0.05
##    stand_x = -stand_width / 2  # Centered at x=0
##    stand_y = -stand_height + 0.016  # Place at the bottom
##    ax.add_patch(Rectangle((stand_x, stand_y), stand_width, stand_height, facecolor='black'))
##

    # Save the chart as an image
    image_path = r'reports\threat_meter.png'
    plt.savefig(image_path)
    
    # Optionally display the chart
    plt.tight_layout()
    plt.close()

    return image_path


# GENERATE DLL HISTOGRAM

def plot_process_execution_histogram(input_file):
    process_counts = defaultdict(int)

    with open(input_file, 'r', newline='', encoding='utf-8') as csv_file:
        reader = csv.reader(csv_file)
        headers = next(reader)  # Read the header row

        # Dynamically identify the "Process Name" and "Operation" columns
        process_name_index = None
        operation_index = None
        for i, header in enumerate(headers):
            if "Process Name" in header:
                process_name_index = i
            elif "Operation" in header:
                operation_index = i

        if process_name_index is None or operation_index is None:
            print("Error: 'Process Name' or 'Operation' column not found in the CSV file.")
            return

        for row in reader:
            operation = row[operation_index].strip()
            
            # Check if the operation is "Load Image"
            if operation == "Load Image":
                current_process_name = row[process_name_index].strip()
                process_counts[current_process_name] += 1

    # Extract the process names and their counts
    processes = list(process_counts.keys())
    counts = list(process_counts.values())

    # Create a histogram
    plt.figure(figsize=(10, 6))
    plt.bar(processes, counts, color='skyblue')
    plt.xlabel('Process Name')
    plt.ylabel('Frequency')
    plt.title('Process Execution Histogram (Load Image)')
    plt.xticks(rotation=90)
    plt.grid(axis='y', alpha=0.75)
    plt.tight_layout()

    # Save the chart as an image
    histogram_image_path = r'reports\load_image_histogram.png'
    plt.savefig(histogram_image_path)
    # Optionally display the chart
    #plt.show()
    plt.close()

# VIRUS TOTAL DISTRIBUTION OF CATEGORIES GRAPH

def plot_distribution_of_categories():

    json_data_file = r'reports/virustotal_results.txt'
    with open(json_data_file, 'r') as file:
        json_data = json.load(file)
    
    # Extract necessary data
    stats = json_data["data"]["attributes"]["stats"]
    
    # Define colors for specific categories
    category_colors = {
        "type-unsupported": 'purple',
        "harmless": 'green',
        "undetected": 'grey',
        "malicious": 'red',
        "suspicious": 'orange',
        "confirmed-timeout": 'blue',
        "timeout": 'pink',
        "failure": 'yellow',
    }
    
    # Extract the keys (categories) and their counts
    categories = list(stats.keys())
    counts = list(stats.values())
    total = sum(counts)
    
    # Calculate percentages
    percentages = [(count/total)*100 for count in counts]
    
    # Create labels for the legend which include the category and percentage
    labels_with_percentages = [f'{category} ({percentage:.2f}%)' for category, percentage in zip(categories, percentages)]
    
    # Create a pie chart
    fig, ax = plt.subplots(figsize=(10,6))
    colors = [category_colors[category] for category in categories]
    
    # Plotting the pie chart with edgecolors and linewidth for borders
    wedges = ax.pie(counts, startangle=90, colors=colors, labels=None, autopct=None, wedgeprops=dict(edgecolor='black', linewidth=1))
    
    
    # Position the labels outside of the pie using legend
    ax.legend(wedges[0], labels_with_percentages, title="Categories", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
    
    # Save the chart as an image
    chart_image = r'reports/AVStat_PieChart.png'
    plt.savefig(chart_image, bbox_inches='tight')  # bbox_inches='tight' to fit the legend in the saved image
    plt.close()

    return chart_image


# GENERATE OUTPUT PCAP GRAPH
##def generate_output_pcap():
##    reports_folder = r'reports'
##    pcap_file_path = None
##    for filename in os.listdir(reports_folder):
##        if filename.endswith(".pcap"):
##            pcap_file_path = os.path.join(reports_folder, filename)
##            break
##
##    if not pcap_file_path:
##        print("No .pcap file found in the 'reports' folder. Exiting.")
##        return
##
##    # Check if the file exists
##    if not os.path.exists(pcap_file_path):
##        print("File does not exist")
##        return
##
##    save_dir = os.path.dirname(pcap_file_path)
##    fixed_pcap_file_path = os.path.join(save_dir, "fixed.pcap")
##
##    try:
##        subprocess.run(["C:\Program Files\Wireshark\editcap.exe", "-F", "pcap", pcap_file_path, fixed_pcap_file_path], check=True)
##    except subprocess.CalledProcessError as e:
##        print(f"Error fixing the .pcap file: {e}")
##        return
##    
##    # Read the pcap file using pyshark
##    cap = pyshark.FileCapture(fixed_pcap_file_path)
##    
##    # Extract the highest protocol layers for pie chart visualization
##    protocolList = []
##    for packet in cap:
##        protocol = packet.highest_layer if hasattr(packet, "highest_layer") else "Unknown"
##        protocolList.append(protocol)
##    counter = collections.Counter(protocolList)
##    protocols = list(counter.keys())
##    frequencies = list(counter.values())
##
##    # Generate the pie chart
##    plt.figure(figsize=(8,6))
##    plt.pie(frequencies, labels=protocols, autopct='%1.1f%%', startangle=90)
##    plt.axis('equal')
##    plt.title("Protocol Distribution")
##    pie_filename = os.path.join(save_dir, "ProtocolPieChart.png")
##    plt.savefig(pie_filename)
##    plt.close()
##    print(f"Generated Protocol Distribution pie chart at: {pie_filename}")
##
##    # Reinitialize pyshark.FileCapture for packet processing
##    cap = pyshark.FileCapture(fixed_pcap_file_path)
##    
##    packet_data = []
##    for packet in cap:
##        try:
##            timestamp = packet.sniff_time
##            packet_length = packet.length
##            src_ip = packet.ip.src
##            dst_ip = packet.ip.dst
##            protocol = packet.transport_layer
##        except AttributeError:
##            continue
##        packet_dict = {
##            'Timestamp': timestamp,
##            'Packet Length': packet_length,
##            'Source IP': src_ip,
##            'Destination IP': dst_ip,
##            'Protocol': protocol
##        }
##        packet_data.append(packet_dict)
##    
##    df = pd.DataFrame(packet_data)
##
##    if df.empty:
##        print("No valid packet data found in the pcap file to generate the table.")
##        return None
##
##    fig, ax = plt.subplots(figsize=(12, 8))
##    ax.axis('tight')
##    ax.axis('off')
##    table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center', colColours=['#f5f5f5']*df.shape[1])
##    table.set_fontsize(10)
##    table.scale(1.0, 1.5)
##    table.auto_set_column_width(col=list(range(len(df.columns))))
##
##    table_filename = os.path.join(save_dir, "PCAP_Table.png")
##    plt.savefig(table_filename)
##    plt.close()
##    print(f"Generated PCAP table at: {table_filename}")
##
##    return table_filename

