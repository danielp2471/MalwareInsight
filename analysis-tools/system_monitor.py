"""
    Group 40 - Malware Sandbox
        Swinburne University of Technology
        Name: MalwareInsight Analysis Script
        Author: Daniel Pesavento
        Date: 7/07/2023
        Dependencies:
            - MalwareInsight supplied ProcmonConfiguration.pmc file including tailored filters
            - Folder containing Process Monitor (procmon.exe)
            - Folder containing FakeNet (fakenet.exe)
        
        Description:
        This script is a monitoring tool that captures system and network activities and generates log files for further analysis. 
        It utilizes two external tools, Process Monitor and FakeNet respectively, to gather the necessary data. 
        Here is a breakdown of the script's functionality:

        1. The user is prompted to select the folder where procmon.exe (Process Monitor) is installed.
        2. The user is prompted to select the folder where fakenet.exe (FakeNet) is installed.
        3. The script initializes the monitoring tools by starting Process Monitor and FakeNet.
            - procmon.exe is initialized with a .pmc filter to remove noisy/unimportant idle system events
            - fakenet.exe is initialized in its specified directory, launching with no console ouput, log location and utilizing the default.ini configuration.
        4. The user can press 'Q' to finish the monitoring process.
            - Both processes are terminated.
            - The Process Monitor output.pml is opened, filter applied, and extracted as a .csv.
            - The Fakenet log output is directed toward to current working directory of this script.
        5. The script creates a zip file named reports.zip on the user's desktop.
        6. The monitor_report.csv file and fakenet_logs.txt file are added to the zip file, awaiting retrieval from the MalwareInsight Host Client.
        Overall, this script provides an automated way to monitor system (file events, registry events, DLL Loads) and network activities, generate reports, and package them into a compressed file for easy distribution or analysis.
"""
import subprocess
import hashlib
import time
import os
import shutil
import zipfile
import csv
import tkinter as tk
from tkinter import filedialog, messagebox

# Get the script's directory
script_directory = os.path.dirname(os.path.abspath(__file__))

root = tk.Tk()
root.withdraw()
print("Please select the Malware/File sample (.exe, .pdf, macro)")
sample_file_path = filedialog.askopenfilename(title="Select Sample file", initialdir=script_directory)
if not sample_file_path:
    messagebox.showerror("Error", "Sample file not selected. Exiting.")
    exit()
print("Please select the folder where procmon.exe is installed.")
# Prompt the user to select the directory where procmon.exe is installed

procmon_directory = filedialog.askdirectory(title="Select Process Monitor Directory",
                                            initialdir=script_directory)
if not procmon_directory:
    messagebox.showerror("Error", "Process Monitor directory not selected. Exiting.")
    exit()

print("Please select the folder where fakenet.exe is installed.")
# Prompt the user to select the directory where fakenet.exe is installed
fakenet_directory = filedialog.askdirectory(title="Select FakeNet Directory",
                                            initialdir=script_directory)
if not fakenet_directory:
    messagebox.showerror("Error", "FakeNet directory not selected. Exiting.")
    exit()

# Set the paths to the required files
procmon_path = os.path.join(procmon_directory, 'Procmon.exe')
fakenet_path = os.path.join(fakenet_directory, 'fakenet.exe')
output_file = os.path.join(script_directory, 'output.PML')
report_file = os.path.join(script_directory, 'monitor_report.csv')
filter_file = os.path.join(script_directory, 'ProcmonConfiguration.pmc')
fake_net_log_file = os.path.join(script_directory, 'fakenet_logs.txt')

# Function to calculate file hashes
def calculate_file_hashes(file_path):
    md5_hash = hashlib.md5()
    sha1_hash = hashlib.sha1()
    sha256_hash = hashlib.sha256()

    with open(file_path, "rb") as file:
        while True:
            data = file.read(8192)
            if not data:
                break
            md5_hash.update(data)
            sha1_hash.update(data)
            sha256_hash.update(data)

    return {
        "MD5": md5_hash.hexdigest(),
        "SHA1": sha1_hash.hexdigest(),
        "SHA256": sha256_hash.hexdigest()
    }

# Calculate file hashes
malicious_file_hashes = calculate_file_hashes(sample_file_path)

print("Initializing monitoring tools...")
# Start Process Monitor with the modified PMC file and backing file
subprocess.Popen([procmon_path, '/AcceptEula', '/Minimized', '/LoadConfig', filter_file, '/Backingfile', output_file])
time.sleep(5)

# Change the current working directory to the FakeNet directory
os.chdir(fakenet_directory)

# Start FakeNet process with the fake_net_log_file path
fake_net_process = subprocess.Popen(['fakenet.exe', '-l', fake_net_log_file],
                                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                    startupinfo=subprocess.STARTUPINFO(), creationflags=subprocess.CREATE_NO_WINDOW)
time.sleep(1)
os.chdir(script_directory)

# Wait until the FakeNet log file is present
while not os.path.exists(fake_net_log_file):
    time.sleep(1)

print("Monitoring is ready. Press 'q' to finish monitoring.")

# Terminate Process Monitor and FakeNet
while True:
    user_input = input().lower()
    if user_input == 'q':
        break
    time.sleep(1)

print("Ending monitoring...please await at least 15 seconds for exports and file gathering to finalize.")
# Terminate FakeNet process
subprocess.run(['taskkill', '/F', '/IM', 'fakenet.exe'])

# Terminate Process Monitor
subprocess.Popen([procmon_path, '/Terminate'])
time.sleep(15)

# Generate report using Procmon's built-in functionality with the filter applied
procmon_export_process = subprocess.Popen([procmon_path, '/OpenLog', output_file, '/SaveAs', report_file, '/SaveApplyFilter', '/Quiet'])
procmon_export_process.wait()

output_csv_path = os.path.join(script_directory, "malicious_file_details.csv")
with open(output_csv_path, "w", newline="", encoding="utf-8") as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=["Sample Name", "MD5", "SHA1", "SHA256"])
    writer.writeheader()
    writer.writerow({"Sample Name": os.path.basename(sample_file_path), **malicious_file_hashes})

# Get the path to the user's home directory
home_directory = os.path.expanduser("~")

# Define the path to the reports zip file on the Desktop
zip_file_path = os.path.join(home_directory, 'Desktop', 'reports.zip')

# Create the zip file and add the files to it
with zipfile.ZipFile(zip_file_path, 'w') as zip_file:
    zip_file.write(report_file, 'monitor_report.csv')
    zip_file.write(fake_net_log_file, 'fakenet_logs.txt')
    zip_file.write(output_csv_path, 'malicious_file_details.csv')


# Display a message box with the location of the reports.zipfile
messagebox.showinfo("Reports", f"Reports have been saved to:\n{zip_file_path}")

