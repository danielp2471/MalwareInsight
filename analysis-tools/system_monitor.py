"""
    Group 40 - Malware Sandbox
        Swinburne University of Technology
        Name: MalwareInsight Analysis Script
        Author: Daniel Pesavento
        Date: 4/09/2023
        Dependencies:
            - MalwareInsight supplied ProcmonConfiguration.pmc file including tailored filters
            - Folder containing Process Monitor (procmon.exe)
            - Folder containing FakeNet (fakenet.exe)
        
        Description:
        This script is a monitoring tool that captures system and network activities and generates log files for further analysis. 
        It utilizes two external tools, Process Monitor and FakeNet respectively, to gather the necessary data. 
        Here is a breakdown of the script's functionality:

        1. The user is prompted to select the folder where procmon.exe (Process Monitor) is installed.
        2. The user is prompted to select the folder where fakenet.exe (FakeNet) is installed.
        3. The script initializes the monitoring tools by starting Process Monitor and FakeNet.
            - procmon.exe is initialized with a .pmc filter to remove noisy/unimportant idle system events
            - fakenet.exe is initialized in its specified directory, launching with no console ouput, log location and utilizing the default.ini configuration.
        4. The user can press 'Q' to finish the monitoring process.
            - Both processes are terminated.
            - The Process Monitor output.pml is opened, filter applied, and extracted as a .csv.
            - The Fakenet log output is directed toward to current working directory of this script.
        5. The script creates a zip file named reports.zip on the user's desktop.
        6. The monitor_report.csv file and fakenet_logs.txt file are added to the zip file, awaiting retrieval from the MalwareInsight Host Client.
        Overall, this script provides an automated way to monitor system (file events, registry events, DLL Loads) and network activities, generate reports, and package them into a compressed file for easy distribution or analysis.
"""
import subprocess
import hashlib
import time
import os
import shutil
import zipfile
import csv
import tkinter as tk
import sys
from tkinter import filedialog, messagebox

ascii_art = '''
 __  __       _                             
 |  \/  |     | |                            
 | \  / | __ _| |_      ____ _ _ __ ___      
 | |\/| |/ _` | \ \ /\ / / _` | '__/ _ \     
 | |  | | (_| | |\ V  V / (_| | | |  __/     
 |_|  |_|\__,_|_| \_/\_/ \__,_|_|  \___|     
           _____           _       _     _   
          |_   _|         (_)     | |   | |  
            | |  _ __  ___ _  __ _| |__ | |_ 
            | | | '_ \/ __| |/ _` | '_ \| __|
           _| |_| | | \__ \ | (_| | | | | |_ 
          |_____|_| |_|___/_|\__, |_| |_|\__|
                              __/ |          
                             |___/          
'''

print(ascii_art)


# Get the script's directory
script_directory = os.path.dirname(os.path.abspath(sys.argv[0]))
root = tk.Tk()
root.withdraw()
def ask_for_file(prompt, filetypes):
    while True:
        print(prompt)
        file_path = filedialog.askopenfilename(title="Select File", initialdir=script_directory, filetypes=filetypes)
        if file_path:
            return file_path
        else:
            messagebox.showerror("Error", "File not selected. Please try again.")

def ask_for_directory(prompt):
    while True:
        print(prompt)
        directory_path = filedialog.askdirectory(title="Select Directory", initialdir=script_directory)
        if directory_path:
            return directory_path
        else:
            messagebox.showerror("Error", "Directory not selected. Please try again.")

# Ask for the sample file
sample_file_path = ask_for_file("Please select the Malware/File sample (.exe, .pdf, macro)",
                                [("All files", "*.*"), ("Executable files", "*.exe"), ("PDF files", "*.pdf")])

# Ask for the Process Monitor directory
procmon_directory = ask_for_directory("Please select the folder where procmon.exe is installed.")
procmon_path = os.path.join(procmon_directory, 'Procmon.exe')
while not os.path.exists(procmon_path):
    messagebox.showerror("Error", "procmon.exe not found in the selected directory. Please try again.")
    procmon_directory = ask_for_directory("Please select the folder where procmon.exe is installed.")
    procmon_path = os.path.join(procmon_directory, 'Procmon.exe')

# Ask for the FakeNet directory
fakenet_directory = ask_for_directory("Please select the folder where fakenet.exe is installed.")
fakenet_path = os.path.join(fakenet_directory, 'fakenet.exe')
while not os.path.exists(fakenet_path):
    messagebox.showerror("Error", "fakenet.exe not found in the selected directory. Please try again.")
    fakenet_directory = ask_for_directory("Please select the folder where fakenet.exe is installed.")
    fakenet_path = os.path.join(fakenet_directory, 'fakenet.exe')

# Now you have valid file paths and directories to proceed with
print("Sample file selected:", sample_file_path)
print("Procmon directory selected:", procmon_directory)
print("FakeNet directory selected:", fakenet_directory)

# Set the paths to the required files
output_file = os.path.join(script_directory, 'output.PML')
report_file = os.path.join(script_directory, 'monitor_report.csv')
filter_file = os.path.join(script_directory, 'ProcmonConfiguration.pmc')
fake_net_log_file = os.path.join(script_directory, 'fakenet_logs.txt')
pcap_directory = fakenet_directory

# Function to calculate file hashes
def calculate_file_hashes(file_path):
    md5_hash = hashlib.md5()
    sha1_hash = hashlib.sha1()
    sha256_hash = hashlib.sha256()

    with open(file_path, "rb") as file:
        while True:
            data = file.read(8192)
            if not data:
                break
            md5_hash.update(data)
            sha1_hash.update(data)
            sha256_hash.update(data)

    return {
        "MD5": md5_hash.hexdigest(),
        "SHA1": sha1_hash.hexdigest(),
        "SHA256": sha256_hash.hexdigest()
    }

# Calculate file hashes
malicious_file_hashes = calculate_file_hashes(sample_file_path)

print("Initializing monitoring tools...")
# Start Process Monitor with the modified PMC file and backing file
subprocess.Popen([procmon_path, '/AcceptEula', '/Minimized', '/LoadConfig', filter_file, '/Backingfile', output_file])
time.sleep(5)

# Change the current working directory to the FakeNet directory
os.chdir(fakenet_directory)

# Start FakeNet process with the fake_net_log_file path
fake_net_process = subprocess.Popen(['fakenet.exe', '-l', fake_net_log_file],
                                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                    startupinfo=subprocess.STARTUPINFO(), creationflags=subprocess.CREATE_NO_WINDOW)
time.sleep(1)
os.chdir(script_directory)

# Wait until the FakeNet log file is present
while not os.path.exists(fake_net_log_file):
    time.sleep(1)

print("Monitoring is ready. Press 'q' to finish monitoring.")

# Terminate Process Monitor and FakeNet
while True:
    user_input = input().lower()
    if user_input == 'q':
        break
    time.sleep(1)

print("Ending monitoring...please await at least 15 seconds for exports and file gathering to finalize.")
# Terminate FakeNet process
subprocess.run(['taskkill', '/F', '/IM', 'fakenet.exe'])

# Terminate Process Monitor
subprocess.Popen([procmon_path, '/Terminate'])
time.sleep(15)

# Generate report using Procmon's built-in functionality with the filter applied
procmon_export_process = subprocess.Popen([procmon_path, '/OpenLog', output_file, '/SaveAs', report_file, '/SaveApplyFilter', '/Quiet'])
procmon_export_process.wait()

output_csv_path = os.path.join(script_directory, "malicious_file_details.csv")
with open(output_csv_path, "w", newline="", encoding="utf-8") as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=["Sample Name", "MD5", "SHA1", "SHA256"])
    writer.writeheader()
    writer.writerow({"Sample Name": os.path.basename(sample_file_path), **malicious_file_hashes})

# Get the path to the user's home directory
home_directory = os.path.expanduser("~")

# Define the path to the reports zip file on the Desktop
zip_file_path = os.path.join(home_directory, 'Desktop', 'reports.zip')

# Create the zip file and add the files to it
with zipfile.ZipFile(zip_file_path, 'w') as zip_file:
    zip_file.write(report_file, 'monitor_report.csv')
    zip_file.write(fake_net_log_file, 'fakenet_logs.txt')

    # Check if any .pcap file is present in the pcap directory
    pcap_files = [f for f in os.listdir(pcap_directory) if f.lower().endswith('.pcap')]
    if pcap_files:
        for pcap_file in pcap_files:
            zip_file.write(os.path.join(pcap_directory, pcap_file), pcap_file)

    zip_file.write(output_csv_path, 'malicious_file_details.csv')


# Display a message box with the location of the reports.zip file
messagebox.showinfo("Reports", f"Reports have been saved to:\n{zip_file_path}")


